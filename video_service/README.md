# Video Service

ÐœÐ¸ÐºÑ€Ð¾ÑÐµÑ€Ð²Ð¸Ñ Ð´Ð»Ñ Ð³ÐµÐ½ÐµÑ€Ð°Ñ†Ð¸Ð¸ Ð²Ð¸Ð´ÐµÐ¾ Ð¸Ð· Ð°ÑƒÐ´Ð¸Ð¾ Ð¸ Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ð¹.

## Ð¢ÐµÐºÑƒÑ‰Ð¸Ð¹ ÑÑ‚Ð°Ñ‚ÑƒÑ

**ðŸŸ¢ Ð ÐÐ‘ÐžÐ¢ÐÐ•Ð¢** - Ð¡ÐµÑ€Ð²Ð¸Ñ Ð½Ð°ÑÑ‚Ñ€Ð¾ÐµÐ½ Ð¸ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¾Ð½Ð¸Ñ€ÑƒÐµÑ‚ Ð² Ñ€ÐµÐ¶Ð¸Ð¼Ðµ Ñ‚ÐµÑÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ

### Ð ÐµÐ¶Ð¸Ð¼Ñ‹ Ñ€Ð°Ð±Ð¾Ñ‚Ñ‹

1. **ÐŸÑ€Ð¾ÑÑ‚Ð¾Ð¹ Ñ€ÐµÐ¶Ð¸Ð¼ (Ñ‚ÐµÐºÑƒÑ‰Ð¸Ð¹)** - SimpleVideoService
   - Ð¡Ð¾Ð·Ð´Ð°ÐµÑ‚ Ð¼Ð¾Ðº-Ð²Ð¸Ð´ÐµÐ¾ Ð´Ð»Ñ Ñ‚ÐµÑÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ
   - ÐÐµ Ñ‚Ñ€ÐµÐ±ÑƒÐµÑ‚ MoviePy 
   - Ð“ÐµÐ½ÐµÑ€Ð¸Ñ€ÑƒÐµÑ‚ Ð¼ÐµÑ‚Ð°Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð²Ð¸Ð´ÐµÐ¾
   - ÐŸÐ¾Ð´Ñ…Ð¾Ð´Ð¸Ñ‚ Ð´Ð»Ñ Ð¸Ð½Ñ‚ÐµÐ³Ñ€Ð°Ñ†Ð¸Ð¾Ð½Ð½Ð¾Ð³Ð¾ Ñ‚ÐµÑÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ

2. **ÐŸÐ¾Ð»Ð½Ñ‹Ð¹ Ñ€ÐµÐ¶Ð¸Ð¼** - VideoService Ñ MoviePy
   - Ð ÐµÐ°Ð»ÑŒÐ½Ð°Ñ Ð³ÐµÐ½ÐµÑ€Ð°Ñ†Ð¸Ñ Ð²Ð¸Ð´ÐµÐ¾
   - Ð¢Ñ€ÐµÐ±ÑƒÐµÑ‚ ÑƒÑÑ‚Ð°Ð½Ð¾Ð²ÐºÐ¸ MoviePy
   - ÐŸÐ¾Ð»Ð½Ð°Ñ Ð¿Ð¾Ð´Ð´ÐµÑ€Ð¶ÐºÐ° ÑÑ„Ñ„ÐµÐºÑ‚Ð¾Ð² (Ken Burns Ð¸ Ð´Ñ€.)

## Ð’Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ÑÑ‚Ð¸

- Ð“ÐµÐ½ÐµÑ€Ð°Ñ†Ð¸Ñ Ð²Ð¸Ð´ÐµÐ¾ Ð¸Ð· Ð°ÑƒÐ´Ð¸Ð¾ Ñ„Ð°Ð¹Ð»Ð° Ð¸ Ð¿Ð¾ÑÐ»ÐµÐ´Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒÐ½Ð¾ÑÑ‚Ð¸ Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ð¹
- ÐŸÐ¾Ð´Ð´ÐµÑ€Ð¶ÐºÐ° ÑÑ„Ñ„ÐµÐºÑ‚Ð° Ken Burns (Ð¿Ð»Ð°Ð²Ð½Ð¾Ðµ ÑƒÐ²ÐµÐ»Ð¸Ñ‡ÐµÐ½Ð¸Ðµ Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ð¹)
- ÐÐ°ÑÑ‚Ñ€Ð°Ð¸Ð²Ð°ÐµÐ¼Ñ‹Ðµ Ð¿ÐµÑ€ÐµÑ…Ð¾Ð´Ñ‹ Ð¼ÐµÐ¶Ð´Ñƒ ÑÐ»Ð°Ð¹Ð´Ð°Ð¼Ð¸
- ÐÐ²Ñ‚Ð¾Ð¼Ð°Ñ‚Ð¸Ñ‡ÐµÑÐºÐ°Ñ ÑÐ¸Ð½Ñ…Ñ€Ð¾Ð½Ð¸Ð·Ð°Ñ†Ð¸Ñ Ð´Ð»Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ÑÑ‚Ð¸ Ð²Ð¸Ð´ÐµÐ¾ Ñ Ð°ÑƒÐ´Ð¸Ð¾
- Ð˜Ð½Ñ‚ÐµÐ³Ñ€Ð°Ñ†Ð¸Ñ Ñ Redis Ð´Ð»Ñ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ¸ Ð·Ð°Ð´Ð°Ñ‡
- ÐŸÐ¾Ð´Ð´ÐµÑ€Ð¶ÐºÐ° Ñ€Ð°Ð·Ð»Ð¸Ñ‡Ð½Ñ‹Ñ… Ñ€Ð°Ð·Ñ€ÐµÑˆÐµÐ½Ð¸Ð¹ Ð¸ FPS

## API Endpoints

### GET /health
ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ñ ÑÐµÑ€Ð²Ð¸ÑÐ°.

### POST /generateVideo
Ð“ÐµÐ½ÐµÑ€Ð°Ñ†Ð¸Ñ Ð²Ð¸Ð´ÐµÐ¾ Ð¸Ð· Ð°ÑƒÐ´Ð¸Ð¾ Ð¸ Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ð¹.

**ÐŸÐ°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹:**
- `audio_path`: ÐŸÑƒÑ‚ÑŒ Ðº Ð°ÑƒÐ´Ð¸Ð¾ Ñ„Ð°Ð¹Ð»Ñƒ
- `image_paths`: Ð¡Ð¿Ð¸ÑÐ¾Ðº Ð¿ÑƒÑ‚ÐµÐ¹ Ðº Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸ÑÐ¼
- `fps`: Ð§Ð°ÑÑ‚Ð¾Ñ‚Ð° ÐºÐ°Ð´Ñ€Ð¾Ð² (Ð¿Ð¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ: 24)
- `resolution`: Ð Ð°Ð·Ñ€ÐµÑˆÐµÐ½Ð¸Ðµ Ð²Ð¸Ð´ÐµÐ¾ (Ð¿Ð¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ: [1920, 1080])
- `slide_duration`: Ð”Ð»Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ÑÑ‚ÑŒ ÐºÐ°Ð¶Ð´Ð¾Ð³Ð¾ ÑÐ»Ð°Ð¹Ð´Ð° Ð² ÑÐµÐºÑƒÐ½Ð´Ð°Ñ… (Ð¿Ð¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ: 3.0)
- `transition_duration`: Ð”Ð»Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ÑÑ‚ÑŒ Ð¿ÐµÑ€ÐµÑ…Ð¾Ð´Ð° Ð¼ÐµÐ¶Ð´Ñƒ ÑÐ»Ð°Ð¹Ð´Ð°Ð¼Ð¸ (Ð¿Ð¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ: 0.5)
- `enable_ken_burns`: Ð’ÐºÐ»ÑŽÑ‡Ð¸Ñ‚ÑŒ ÑÑ„Ñ„ÐµÐºÑ‚ Ken Burns (Ð¿Ð¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ: true)
- `zoom_factor`: ÐšÐ¾ÑÑ„Ñ„Ð¸Ñ†Ð¸ÐµÐ½Ñ‚ ÑƒÐ²ÐµÐ»Ð¸Ñ‡ÐµÐ½Ð¸Ñ Ð´Ð»Ñ ÑÑ„Ñ„ÐµÐºÑ‚Ð° Ken Burns (Ð¿Ð¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ: 1.1)

## Redis Tasks

Ð¡ÐµÑ€Ð²Ð¸Ñ Ð¾Ð±Ñ€Ð°Ð±Ð°Ñ‚Ñ‹Ð²Ð°ÐµÑ‚ Ð·Ð°Ð´Ð°Ñ‡Ð¸ Ð¸Ð· Ð¾Ñ‡ÐµÑ€ÐµÐ´Ð¸ `queue:video-service`:

### CreateVideo / GenerateVideo / CreateVideoFromSlides
Ð“ÐµÐ½ÐµÑ€Ð¸Ñ€ÑƒÐµÑ‚ Ð²Ð¸Ð´ÐµÐ¾ Ð¸Ð· Ð°ÑƒÐ´Ð¸Ð¾ Ð¸ Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ð¹.

**Ð—Ð°Ð²Ð¸ÑÐ¸Ð¼Ð¾ÑÑ‚Ð¸:**
- `voice_track_id`: ID Ð·Ð°Ð´Ð°Ñ‡Ð¸ Ð³ÐµÐ½ÐµÑ€Ð°Ñ†Ð¸Ð¸ Ð°ÑƒÐ´Ð¸Ð¾
- `slide_ids`: Ð¡Ð¿Ð¸ÑÐ¾Ðº ID Ð·Ð°Ð´Ð°Ñ‡ Ð³ÐµÐ½ÐµÑ€Ð°Ñ†Ð¸Ð¸ Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ð¹

**ÐŸÐ°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹:**
- Ð’ÑÐµ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ Ð°Ð½Ð°Ð»Ð¾Ð³Ð¸Ñ‡Ð½Ñ‹ API endpoint

## ÐšÐ¾Ð½Ñ„Ð¸Ð³ÑƒÑ€Ð°Ñ†Ð¸Ñ

ÐŸÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ðµ Ð¾ÐºÑ€ÑƒÐ¶ÐµÐ½Ð¸Ñ:
- `REDIS_HOST`: Ð¥Ð¾ÑÑ‚ Redis (Ð¿Ð¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ: "redis")
- `REDIS_PORT`: ÐŸÐ¾Ñ€Ñ‚ Redis (Ð¿Ð¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ: 6379)
- `OUTPUT_DIR`: Ð”Ð¸Ñ€ÐµÐºÑ‚Ð¾Ñ€Ð¸Ñ Ð´Ð»Ñ Ð²Ñ‹Ñ…Ð¾Ð´Ð½Ñ‹Ñ… Ñ„Ð°Ð¹Ð»Ð¾Ð² (Ð¿Ð¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ: "/app/output")

## Ð—Ð°Ð²Ð¸ÑÐ¸Ð¼Ð¾ÑÑ‚Ð¸

**Ð‘Ð°Ð·Ð¾Ð²Ñ‹Ðµ (Ð²ÑÐµÐ³Ð´Ð° Ñ‚Ñ€ÐµÐ±ÑƒÑŽÑ‚ÑÑ):**
- FastAPI
- Redis
- Pillow
- NumPy

**Ð”Ð¾Ð¿Ð¾Ð»Ð½Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ðµ (Ð´Ð»Ñ Ð¿Ð¾Ð»Ð½Ð¾Ð³Ð¾ Ñ€ÐµÐ¶Ð¸Ð¼Ð°):**
- MoviePy (Ð·Ð°ÐºÐ¾Ð¼Ð¼ÐµÐ½Ñ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½ Ð² requirements.txt Ð´Ð»Ñ Ñ‚ÐµÑÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ)

## Ð¢ÐµÑÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ

Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹Ñ‚Ðµ PowerShell ÑÐºÑ€Ð¸Ð¿Ñ‚ Ð´Ð»Ñ Ñ‚ÐµÑÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ:

```powershell
pwsh -File test_video_service.ps1
```

## Ð—Ð°Ð¿ÑƒÑÐº

### Ð’ Docker (Ñ€ÐµÐºÐ¾Ð¼ÐµÐ½Ð´ÑƒÐµÑ‚ÑÑ)
```bash
docker-compose up video-service
```

### Ð›Ð¾ÐºÐ°Ð»ÑŒÐ½Ð¾
```bash
uvicorn app:app --host 0.0.0.0 --port 8004
```

## ÐŸÐµÑ€ÐµÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ðµ Ð½Ð° Ð¿Ð¾Ð»Ð½Ñ‹Ð¹ Ñ€ÐµÐ¶Ð¸Ð¼

Ð”Ð»Ñ Ð²ÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ñ Ð¿Ð¾Ð»Ð½Ð¾Ð¹ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¾Ð½Ð°Ð»ÑŒÐ½Ð¾ÑÑ‚Ð¸ Ñ MoviePy:

1. Ð Ð°ÑÐºÐ¾Ð¼Ð¼ÐµÐ½Ñ‚Ð¸Ñ€ÑƒÐ¹Ñ‚Ðµ `moviepy==2.2.1` Ð² `requirements.txt`
2. ÐžÐ±Ð½Ð¾Ð²Ð¸Ñ‚Ðµ Ð¸Ð¼Ð¿Ð¾Ñ€Ñ‚ Ð² `routes.py`:
   ```python
   from video_service import VideoService
   video_service = VideoService()
   ```
3. ÐŸÐµÑ€ÐµÑÐ¾Ð±ÐµÑ€Ð¸Ñ‚Ðµ Docker ÐºÐ¾Ð½Ñ‚ÐµÐ¹Ð½ÐµÑ€

## Docker

```bash
docker build -t video-service .
docker run -p 8004:8004 video-service
```





## MoviePy

moviepy.video.compositing.CompositeVideoClip.concatenate_videoclips
moviepy.video.compositing.CompositeVideoClip.concatenate_videoclips(clips, method='chain', transition=None, bg_color=None, is_mask=False, padding=0)[source]
Concatenates several video clips.

Returns a video clip made by clip by concatenating several video clips. (Concatenated means that they will be played one after another).

There are two methods:

method=â€chainâ€: will produce a clip that simply outputs the frames of the successive clips, without any correction if they are not of the same size of anything. If none of the clips have masks the resulting clip has no mask, else the mask is a concatenation of masks (using completely opaque for clips that donâ€™t have masks, obviously). If you have clips of different size and you want to write directly the result of the concatenation to a file, use the method â€œcomposeâ€ instead.

method=â€composeâ€, if the clips do not have the same resolution, the final resolution will be such that no clip has to be resized. As a consequence the final clip has the height of the highest clip and the width of the widest clip of the list. All the clips with smaller dimensions will appear centered. The border will be transparent if mask=True, else it will be of the color specified by bg_color.

The clip with the highest FPS will be the FPS of the result clip.

Parameters
:
clips â€“ A list of video clips which must all have their duration attributes set.

method â€“ â€œchainâ€ or â€œcomposeâ€: see above.

transition â€“ A clip that will be played between each two clips of the list.

bg_color â€“ Only for method=â€™composeâ€™. Color of the background. Set to None for a transparent clip

padding â€“ Only for method=â€™composeâ€™. Duration during two consecutive clips. Note that for negative padding, a clip will partly play at the same time as the clip it follows (negative padding is cool for clips who fade in on one another). A non-null padding automatically sets the method to compose.




---------------------------------------------------------------






moviepy.audio.AudioClip.AudioClip
class moviepy.audio.AudioClip.AudioClip(frame_function=None, duration=None, fps=None)[source]
Base class for audio clips.

See AudioFileClip and CompositeAudioClip for usable classes.

An AudioClip is a Clip with a frame_function attribute of the form `` t -> [ f_t ]`` for mono sound and t-> [ f1_t, f2_t ] for stereo sound (the arrays are Numpy arrays). The f_t are floats between -1 and 1. These bounds can be trespassed without problems (the program will put the sound back into the bounds at conversion time, without much impact).

Parameters
:
frame_function â€“ A function t-> frame at time t. The frame does not mean much for a sound, it is just a float. What â€˜makesâ€™ the sound are the variations of that float in the time.

duration â€“ Duration of the clip (in seconds). Some clips are infinite, in this case their duration will be None.

nchannels â€“ Number of channels (one or two for mono or stereo).

Examples

# Plays the note A in mono (a sine wave of frequency 440 Hz)
import numpy as np
frame_function = lambda t: np.sin(440 * 2 * np.pi * t)
clip = AudioClip(frame_function, duration=5, fps=44100)
clip.preview()

# Plays the note A in stereo (two sine waves of frequencies 440 and 880 Hz)
frame_function = lambda t: np.array([
    np.sin(440 * 2 * np.pi * t),
    np.sin(880 * 2 * np.pi * t)
]).T.copy(order="C")
clip = AudioClip(frame_function, duration=3, fps=44100)
clip.preview()
audiopreview(fps=None, buffersize=2000, nbytes=2, audio_flag=None, video_flag=None)[source]
Preview an AudioClip using ffplay

Parameters
:
fps â€“ Frame rate of the sound. 44100 gives top quality, but may cause problems if your computer is not fast enough and your clip is complicated. If the sound jumps during the preview, lower it (11025 is still fine, 5000 is tolerable).

buffersize â€“ The sound is not generated all at once, but rather made by bunches of frames (chunks). buffersize is the size of such a chunk. Try varying it if you meet audio problems (but you shouldnâ€™t have to).

nbytes â€“ Number of bytes to encode the sound: 1 for 8bit sound, 2 for 16bit, 4 for 32bit sound. 2 bytes is fine.

audio_flag â€“ Instances of class threading events that are used to synchronize video and audio during VideoClip.preview().

video_flag â€“ Instances of class threading events that are used to synchronize video and audio during VideoClip.preview().

display_in_notebook(filetype=None, maxduration=60, t=None, fps=None, rd_kwargs=None, center=True, **html_kwargs)
Displays clip content in an Jupyter Notebook.

Remarks: If your browser doesnâ€™t support HTML5, this should warn you. If nothing is displayed, maybe your file or filename is wrong. Important: The media will be physically embedded in the notebook.

Parameters
:
clip (moviepy.Clip.Clip) â€“ Either the name of a file, or a clip to preview. The clip will actually be written to a file and embedded as if a filename was provided.

filetype (str, optional) â€“ One of "video", "image" or "audio". If None is given, it is determined based on the extension of filename, but this can bug.

maxduration (float, optional) â€“ An error will be raised if the clipâ€™s duration is more than the indicated value (in seconds), to avoid spoiling the browserâ€™s cache and the RAM.

t (float, optional) â€“ If not None, only the frame at time t will be displayed in the notebook, instead of a video of the clip.

fps (int, optional) â€“ Enables to specify an fps, as required for clips whose fps is unknown.

rd_kwargs (dict, optional) â€“ Keyword arguments for the rendering, like dict(fps=15, bitrate="50k"). Allow you to give some options to the render process. You can, for example, disable the logger bar passing dict(logger=None).

center (bool, optional) â€“ If true (default), the content will be wrapped in a <div align=middle> HTML container, so the content will be displayed at the center.

kwargs â€“ Allow you to give some options, like width=260, etc. When editing looping gifs, a good choice is loop=1, autoplay=1.

Examples

from moviepy import *
# later ...
clip.display_in_notebook(width=360)
clip.audio.display_in_notebook()

clip.write_gif("test.gif")
display_in_notebook('test.gif')

clip.save_frame("first_frame.jpeg")
display_in_notebook("first_frame.jpeg")
iter_chunks(chunksize=None, chunk_duration=None, fps=None, quantize=False, nbytes=2, logger=None)[source]
Iterator that returns the whole sound array of the clip by chunks

max_volume(stereo=False, chunksize=50000, logger=None)[source]
Returns the maximum volume level of the clip.

to_soundarray(tt=None, fps=None, quantize=False, nbytes=2, buffersize=50000)[source]
Transforms the sound into an array that can be played by pygame or written in a wav file. See AudioClip.preview.

Parameters
:
fps â€“ Frame rate of the sound for the conversion. 44100 for top quality.

nbytes â€“ Number of bytes to encode the sound: 1 for 8bit sound, 2 for 16bit, 4 for 32bit sound.

write_audiofile(filename, fps=None, nbytes=2, buffersize=2000, codec=None, bitrate=None, ffmpeg_params=None, write_logfile=False, logger='bar')[source]
Writes an audio file from the AudioClip.

Parameters
:
filename â€“ Name of the output file, as a string or a path-like object.

fps â€“ Frames per second. If not set, it will try default to self.fps if already set, otherwise it will default to 44100.

nbytes â€“ Sample width (set to 2 for 16-bit sound, 4 for 32-bit sound)

buffersize â€“ The sound is not generated all at once, but rather made by bunches of frames (chunks). buffersize is the size of such a chunk. Try varying it if you meet audio problems (but you shouldnâ€™t have to). Default to 2000

codec â€“ Which audio codec should be used. If None provided, the codec is determined based on the extension of the filename. Choose â€˜pcm_s16leâ€™ for 16-bit wav and â€˜pcm_s32leâ€™ for 32-bit wav.

bitrate â€“ Audio bitrate, given as a string like â€˜50kâ€™, â€˜500kâ€™, â€˜3000kâ€™. Will determine the size and quality of the output file. Note that it mainly an indicative goal, the bitrate wonâ€™t necessarily be the this in the output file.

ffmpeg_params â€“ Any additional parameters you would like to pass, as a list of terms, like [â€˜-option1â€™, â€˜value1â€™, â€˜-option2â€™, â€˜value2â€™]

write_logfile â€“ If true, produces a detailed logfile named filename + â€˜.logâ€™ when writing the file

logger â€“ Either "bar" for progress bar or None or any Proglog logger.

-----------------------------------------------------


AudioClip
AudioClip is the base class for all audio clips. If all you want is to edit audio files, you will never need it.

All you need is to define a function frame_function(t) which returns a Nx1 or Nx2 numpy array representing the sound at time t.

from moviepy import AudioClip
import numpy as np


def audio_frame(t):
    """Producing a sinewave of 440 Hz -> note A"""
    return np.sin(440 * 2 * np.pi * t)


audio_clip = AudioClip(frame_function=audio_frame, duration=3)
For more, see AudioClip.

AudioFileClip
AudioFileClip is used to load an audio file. This is probably the only kind of audio clip you will use.

You simply pass it the file you want to load :

from moviepy import *

# Works for audio files, but also videos file where you only want the keep the audio track
clip = AudioFileClip("example.wav")
clip.write_audiofile("./result.wav")
For more, see AudioFileClip.



-------------------------------------------


Working imports:
from moviepy.editor import VideoFileClip
from moviepy.editor import (
    AudioFileClip,
    CompositeVideoClip,
    ImageClip,
    TextClip,
    concatenate_videoclips,
    ColorClip,
    VideoClip,
    vfx
)